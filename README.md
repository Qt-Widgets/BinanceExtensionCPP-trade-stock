

BinanceExtensionCPP
=

# Intro 

This library is an extension for the API of Binance. It is used to help write trading algorithms on Binance. 
<br />The design is delibaretly attempting to reduce runtime execution, by using methods such as CRTP and the `Params` object; no virtual classes/methods are used in this library.
<br /> More performance boosting features are planned to be added in the future. One of them is `constexpr` for string concatenation after the release of C++20.
# Dependencies

	1. JsonCPP https://github.com/open-source-parsers/jsoncpp
	2. CURL https://curl.haxx.se/
	3. Boost/Beast websockets https://github.com/boostorg/beast

These 3 must be installed in order to use the library.


# Documentation
In order to use this library, you must have all dependencies installed. Only one included statement is required - `#include "include/Binance_Client.h"`, and add all content of `/src` directory should be added to the Source files. 
<br />Note that `.inl` files are included inside the main header.
<br /> <br />
<br />You must initialize a `Client` object, which is one of the following: *[SpotClient, FuturesClientUSDT, FuturesClientCoin]*
<br /> **Unique methods** - In order to use *[Wallet, FuturesWallet, SubAccount, MarginAccount, Savings, Mining]* endpoints, they should be initialized from within other Client classes, and by passing the Client object to the constructor.					
i.e:
 >SpotClient::Wallet my_wallet{ my_client_obj }. 
 
<br /> Each of the aforementioned is a struct inside `Client` that contains methods.

## Exchange client
In order to initialize a client that is not public, api-key and api-secret must be passed in std::string format to the constructor.
> FuturesClientUSDT(api_key, api_secret)
> 
<br />Futures clients may be set in testnet mode by using the method "set_testnet_mode(bool)". SpotClient has 'test_new_order' method but no testnet mode endpoints.

- #### CRTP implementation
	The CRTP is implemented as follows:
    <br />
    <br />├── Client
    <br />│        ├── SpotClient
    <br />│        │
    <br />│           └── FuturesClient
    <br />│                │
    <br />│                ├── FuturesClientUSDT
    <br />│                └── FuturesClientCoin
    <br />
    <br /> 
    <br /> 
    As was mentioned earlier, unique endpoints are located as separate structs inside Client.
	<br /> CRTP interface and implementations are separated inside `Binance_Client.cpp`. Generally speaking, implementations are marked by a `v_` prefix.
    <br /> Deeper implementations (i.e `Client` -> `FuturesClient` -> [`FuturesClientUSDT`, `FuturesClientCoin`]) include an additional underscore: `v__`.
- #### Exceptions
	WIP
    
- #### Notes
		1. No copy assignment / constructor are implemented for Client classes. Each object has its own unique Session, WS, and running streams...
		2. All unique endpoint structs require that the client object contains keys and is not a public client.

## REST client
All REST request methods take a pointer to a `Params` object. This object holds the parameters that would be generated to a query string and sent as the request body.
<br /> Endpoints that do not require any params, have a default argument which is a `nullptr` (beware if using threads). 
<br />* Signing requests is done after generating the query, and the `Params` object remains unchanged.
- #### 'Params' object
	The `Params` object holds all parameters in an `unordered_map`, and thus allows quick access and modification during runtime. The idea here is to prepare most of the request body and have it ready at all time. (**i.e: have the side and quantity ready at all times. Price may be set on signal, using the time complexity of `unordered_map` insertion**)
	<br />You can set  or delete parameters from the object using the methods `set_param<type>()` and `delete_param()`. Using`flush_params()` method will delete all params from the object.
	<br />It is also possible to set a default `recvWindow` value that would be set again after each flush, using the `set_recv()` method.
- #### Response type
	Each REST request returns a JSON type objet, that holds the three following keys:
    1. "response" = Actual response from the exchange in std::string format
    2. "request_status" = Request status (bool; 1 success 0 failure)
    3. "parse_status" = Returns a string generated by the JSON parser, containing parsing errors (if any)
    
- #### Custom Requests
	You can send a custom request, using `custom_{request_type}_req() method`.
	<br /> This method accepts four arguments: `base_path` std::string, `endpoint`std::string, `Params` object, and `sign_request` bool (true = append signature to request body).
- #### Notes
   		 1. There are four curl handles that are alive throughout the entire life of a RestSession object, one for each request type: PUT, DELETE, POST, GET.
   		 2. In order to avoid race conditions by using the same handle at the same time for different requests, mutex is used.
## Websocket client
Each time a client object is created, a websocket client is also instantiated. In fact, the websocket client accepts the Client object as an argument.

<br /> The websocket client holds a map of all stream connection names and their current status. **symbol@stream_name** (i.e: btc@aggTrade). This is very crucial to know in order to be able to close a stream by using the `close_stream()` method.
<br />Not all streams accept the same arguments list, but all of them accept an std::string buffer and a functor object to use as callback.

- #### Callback functor
	All streams accepts a reference to std::string buffer and a reference to a functor object. This is implemented using templates, therefore the template type of the stream, when called, should be the type of the functor object. 
	>client_obj.stream_aggTrade<typename SomeFunctor\>(symbol, buff, functor_obj)

	<br /> It would be good practice to set the buffer as a member of the functor object.
- #### Stream Manager
	The WebsocketClient class has a `stream_manager`, which is responsible for the stream connection. It is possible to set `reconnect_on_error` by using Client's `ws_auto_reconnect()` method, and also specify the number of attempts by using `set_max_reconnect_count()` method.
<br />The `stream_manager` closes a stream when the stream status is set to zero by the `close_stream()` method, or if any other error was encountered (unless `reconnect_on_error` is true).
<br /> The stream manager also accepts a `bool` for whether or not to ping a listen key periodically. The ping interval is 30 minutes by default, and can be set using `set_refresh_key_interval()` method (in `Client`).
- #### Custom Streams
	Custom streams are possible by using `Client`'s `custom_stream()` method. This method accepts 4 arguments: `stream_path` std::string, `buffer` std::string, `functor` functor, and `ping_listen_key` bool (when true, pings listen key periodically).

- #### Notes
		1. Default arguments are not allowed with threads. The argument must be specified
		2. When passing a symbol as an argument to a stream starter, the symbol must be lower case.

### Optimizations
For Microsoft compilers set the following flags for better runtime performance:
* Optimization: /O2
* Instrinsic functions: /Oi
* Favor speed: /Ot
* Frame pointers: /Oy (if available)

# Examples
* orderbook_manager.cpp = Connecting to a symbol orderbook and fetching live data + getting initial snap via REST (not thread-safe).


# Lined up
* constexpr for endpoints + api base after the release of c++20 (constexpr support for std::string)
